"""
Repository processor for RepoWalker.

This module handles the end-to-end process of enhancing repositories.
"""
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from colorama import Fore, Style

from .ai_service import AIService, get_ai_service
from .github_api import GitHubAPI
from .repository import RepositoryManager


class RepoProcessor:
    """Process repositories to add AI-generated enhancements."""

    def __init__(
        self,
        github_api: Optional[GitHubAPI] = None,
        repo_manager: Optional[RepositoryManager] = None,
        ai_service: Optional[AIService] = None,
        working_dir: Optional[Path] = None,
        cleanup_after_processing: bool = True,
    ):
        """Initialize the repository processor.

        Args:
            github_api: GitHub API client
            repo_manager: Repository manager
            ai_service: AI service for generating content
            working_dir: Working directory for repository operations
            cleanup_after_processing: Whether to clean up repositories after processing
        """
        self.github_api = github_api or GitHubAPI()
        self.repo_manager = repo_manager or RepositoryManager(working_dir)
        self.ai_service = ai_service or get_ai_service("mock")
        self.cleanup_after_processing = cleanup_after_processing

    def process_repository(
        self,
        repo_info: Dict[str, Any],
        branch_name: Optional[str] = None,
        output_file: str = "README.md",
        commit_message: str = "Add auto-generated documentation",
    ) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """Process a single repository.

        Args:
            repo_info: Repository information from GitHub API
            branch_name: Name of the branch to create (default: auto-generated)
            output_file: Name of the output file to generate
            commit_message: Commit message

        Returns:
            Tuple of (success, pull_request_info)
        """
        repo_name = repo_info["full_name"]
        default_branch = repo_info.get("default_branch", "main")

        # Generate a branch name if not provided
        if not branch_name:
            timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
            branch_name = f"docs/auto-gen-{timestamp}"

        print(f"\n{Fore.CYAN}Processing repository: {repo_name}{Style.RESET_ALL}")

        try:
            # Step 1: Clone or fetch the repository
            repo_dir = self.repo_manager.setup_repository(repo_info)

            # Step 2: Create a new branch
            if not self.repo_manager.create_branch(repo_dir, branch_name):
                raise Exception(f"Failed to create branch {branch_name}")

            # Step 3: Generate documentation
            success, doc_path = self.ai_service.generate_documentation(
                repo_dir, output_file=output_file, context={"repo_info": repo_info}
            )

            if not success:
                raise Exception(f"Failed to generate documentation for {repo_name}")

            # Step 4: Commit and push changes
            if not self.repo_manager.commit_and_push(repo_dir, branch_name, commit_message):
                raise Exception(f"Failed to commit and push changes to {repo_name}")

            # Step 5: Create a pull request
            pr_body = f"""
# Auto-generated Documentation

This pull request adds automatically generated documentation to help improve the repository.

**Generated file:** `{output_file}`

Please review the changes and merge if they look good.

---
*Generated by RepoWalker*
"""

            pr_info = self.github_api.create_pull_request(
                repo_name, branch_name, default_branch, f"Add auto-generated {output_file}", pr_body
            )

            print(f"{Fore.GREEN}Successfully processed {repo_name}{Style.RESET_ALL}")

            # Step 6: Clean up if needed
            if self.cleanup_after_processing:
                self.repo_manager.cleanup(repo_dir)

            return True, pr_info

        except Exception as e:
            print(f"{Fore.RED}Error processing {repo_name}: {e}{Style.RESET_ALL}")

            # Try to clean up the branch if it was created
            try:
                self.repo_manager.cleanup_branch(repo_dir, branch_name)
            except Exception:
                pass

            # Clean up repository directory if needed
            if self.cleanup_after_processing:
                try:
                    self.repo_manager.cleanup(repo_dir)
                except Exception:
                    pass

            return False, None

    def process_repositories(
        self,
        repositories: List[Dict[str, Any]],
        branch_prefix: str = "docs/auto-gen",
        output_file: str = "README.md",
        commit_message: str = "Add auto-generated documentation",
    ) -> Dict[str, List[Dict[str, Any]]]:
        """Process multiple repositories.

        Args:
            repositories: List of repository information from GitHub API
            branch_prefix: Prefix for branch names
            output_file: Name of the output file to generate
            commit_message: Commit message

        Returns:
            Dictionary with success and failure information
        """
        results = {"success": [], "failure": []}

        print(f"{Fore.CYAN}Processing {len(repositories)} repositories...{Style.RESET_ALL}")

        for i, repo_info in enumerate(repositories, 1):
            repo_name = repo_info["full_name"]
            timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
            branch_name = f"{branch_prefix}-{timestamp}"

            print(
                f"\n{Fore.CYAN}[{i}/{len(repositories)}] Processing: {repo_name}{Style.RESET_ALL}"
            )

            success, pr_info = self.process_repository(
                repo_info,
                branch_name=branch_name,
                output_file=output_file,
                commit_message=commit_message,
            )

            if success:
                results["success"].append({"repo": repo_info, "pr": pr_info})
            else:
                results["failure"].append({"repo": repo_info})

        # Print summary
        print(f"\n{Fore.CYAN}Processing complete!{Style.RESET_ALL}")
        print(f"{Fore.GREEN}Successfully processed: {len(results['success'])}{Style.RESET_ALL}")
        print(f"{Fore.RED}Failed: {len(results['failure'])}{Style.RESET_ALL}")

        return results
